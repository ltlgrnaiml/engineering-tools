{
  "schema_type": "adr",
  "id": "ADR-0036_Observability-and-Debugging-First",
  "title": "Observability & Debugging First: Every Operation Must Be Traceable",
  "status": "accepted",
  "date": "2025-12-28",
  "review_date": "2026-06-28",
  "deciders": "Mycahya Eggleston",
  "scope": "core",
  "provenance": [
    {
      "at": "2025-12-28",
      "by": "Mycahya Eggleston",
      "note": "Initial draft to establish observability as first-class architectural concern"
    }
  ],
  "context": "For a solo developer, debugging is the largest time sink. Without comprehensive observability, issues require manual reproduction, print-statement debugging, and guesswork. The deterministic system design (ADR-0004, ADR-0001) provides reproducibility, but without structured logging and tracing, the 'what happened' question remains difficult to answer. Modern observability practices (structured logging, distributed tracing, state snapshots) enable rapid root-cause analysis. This ADR mandates that every operation MUST be traceable, transforming debugging from art to science.",
  "decision_primary": "Every operation MUST be traceable. This requires: (1) Structured JSON logging (not text) for all log messages, (2) Request ID propagated through all API calls and background tasks, (3) FSM stage transitions emit events with before/after state snapshots, (4) ArtifactStore logs every write with SHA-256 hash for content verification, (5) DevTools surfaces a trace viewer for inspecting request flows. All logging uses Python's structlog library for consistent structured output.",
  "decision_details": {
    "approach": "Structured logging with correlation IDs; state snapshots at boundaries; trace viewer for inspection",
    "constraints": [
      "All log messages MUST be structured JSON (no unstructured text logs)",
      "All API requests MUST have a unique request_id header (generated if not provided)",
      "Request ID MUST be propagated to all downstream calls and background tasks",
      "FSM stage transitions MUST emit before_state and after_state in log events",
      "ArtifactStore writes MUST log: artifact_id, content_hash (SHA-256), file_path, timestamp",
      "Error logs MUST include: exception type, message, stack trace, request_id, relevant context",
      "DevTools MUST provide trace viewer for inspecting request flows"
    ],
    "logging_standard": {
      "library": "structlog",
      "format": "JSON lines (one JSON object per log line)",
      "fields": {
        "required": ["timestamp", "level", "event", "request_id"],
        "recommended": ["module", "function", "duration_ms", "user_id"],
        "context_specific": ["stage_id", "artifact_id", "dataset_id", "error_type"]
      },
      "levels": {
        "DEBUG": "Detailed diagnostic information (disabled in production)",
        "INFO": "Normal operation events (request start/end, stage transitions)",
        "WARNING": "Unexpected but handled situations",
        "ERROR": "Failures requiring attention",
        "CRITICAL": "System-level failures"
      }
    },
    "request_tracing": {
      "header": "X-Request-ID",
      "generation": "UUID4 if not provided by client",
      "propagation": "Included in all downstream HTTP calls, background task context",
      "storage": "Bound to structlog context for automatic inclusion in all logs"
    },
    "fsm_state_logging": {
      "events": {
        "stage_transition_start": {
          "fields": ["stage_id", "from_state", "to_state", "trigger", "request_id"],
          "level": "INFO"
        },
        "stage_transition_complete": {
          "fields": ["stage_id", "from_state", "to_state", "duration_ms", "artifacts_created"],
          "level": "INFO"
        },
        "cascade_triggered": {
          "fields": ["source_stage_id", "affected_stages", "cascade_policy"],
          "level": "INFO"
        }
      },
      "state_snapshots": "Full stage state (serialized to JSON) logged at DEBUG level"
    },
    "artifact_logging": {
      "events": {
        "artifact_write": {
          "fields": ["artifact_id", "content_hash", "file_path", "size_bytes", "request_id"],
          "level": "INFO"
        },
        "artifact_read": {
          "fields": ["artifact_id", "file_path", "request_id"],
          "level": "DEBUG"
        }
      }
    },
    "devtools_trace_viewer": {
      "purpose": "Visual inspection of request flows and state transitions",
      "features": [
        "Filter by request_id to see all related log events",
        "Timeline view of stage transitions",
        "State diff viewer (before/after)",
        "Artifact content preview"
      ],
      "implementation": "React component in DevTools frontend; API endpoint for log retrieval"
    },
    "implementation_specs": []
  },
  "consequences": [
    "✅ POSITIVE: Rapid root-cause analysis (filter logs by request_id)",
    "✅ POSITIVE: State transitions are fully auditable",
    "✅ POSITIVE: Artifact integrity verifiable via content hash",
    "✅ POSITIVE: Structured logs enable querying and aggregation",
    "✅ POSITIVE: DevTools trace viewer reduces debugging time",
    "✅ POSITIVE: Solo-dev can 'replay' issues without manual reproduction",
    "❌ NEGATIVE: Increased log volume (mitigated: log levels, retention policy)",
    "❌ NEGATIVE: Structlog learning curve (mitigated: consistent patterns)",
    "❌ NEGATIVE: Performance overhead for state snapshots (mitigated: DEBUG level only)",
    "⚠️ NEUTRAL: JSON logs less human-readable than text (mitigated: trace viewer)"
  ],
  "alternatives_considered": [
    {
      "name": "Text-Based Logging (print statements, logging.info)",
      "pros": "Simple, human-readable, no library dependency",
      "cons": "Unstructured, hard to query, inconsistent format, no correlation",
      "rejected_reason": "Text logs are debugging dead-ends; structured logs enable analysis"
    },
    {
      "name": "Full Distributed Tracing (OpenTelemetry, Jaeger)",
      "pros": "Industry standard, rich visualization, span-based tracing",
      "cons": "Infrastructure overhead, overkill for local-first tools",
      "rejected_reason": "Solo-dev local tools don't need distributed tracing infrastructure"
    },
    {
      "name": "Logging Only on Errors",
      "pros": "Minimal log volume, simple implementation",
      "cons": "No context for errors, can't trace normal flows, blind to performance issues",
      "rejected_reason": "Need visibility into normal operations, not just failures"
    }
  ],
  "tradeoffs": "We trade log volume for debuggability. Structured JSON logs are less human-readable but enable powerful querying. State snapshots add overhead but provide full reproducibility.",
  "rollout_plan": [
    "1. Add structlog to dependencies; configure JSON output",
    "2. Implement request_id middleware for FastAPI",
    "3. Update all logging calls to use structlog with bound context",
    "4. Add FSM transition logging to stage orchestrator",
    "5. Add artifact logging to ArtifactStore",
    "6. Create DevTools trace viewer component",
    "7. Add log retrieval API endpoint for DevTools"
  ],
  "rollback_plan": "If structured logging proves too verbose: (1) Reduce log levels (INFO → WARNING for routine events), (2) Disable state snapshots (DEBUG level), (3) Keep request_id propagation (low overhead, high value). Incremental rollback possible.",
  "metrics_to_watch": [
    "Time to debug issues (should decrease with trace viewer)",
    "Log volume (monitor storage; adjust retention)",
    "Log query latency (trace viewer responsiveness)"
  ],
  "guardrails": [
    {
      "id": "observability-structured-logging",
      "rule": "All log messages MUST be structured JSON via structlog",
      "enforcement": "Code review; linter rule for logging.* calls (should use structlog)",
      "scope": "core"
    },
    {
      "id": "observability-request-id-required",
      "rule": "All API requests MUST have request_id propagated through call chain",
      "enforcement": "Middleware generates/propagates; logs without request_id flagged",
      "scope": "core"
    },
    {
      "id": "observability-fsm-logging",
      "rule": "FSM stage transitions MUST emit structured log events",
      "enforcement": "Stage orchestrator includes logging; tests verify log output",
      "scope": "core"
    },
    {
      "id": "observability-artifact-logging",
      "rule": "ArtifactStore writes MUST log artifact_id and content_hash",
      "enforcement": "ArtifactStore includes logging; tests verify log output",
      "scope": "core"
    }
  ],
  "cross_cutting_guardrails": [
    "ADR-0004: Content-addressed IDs enable artifact verification via hash",
    "ADR-0008: Timestamps in logs use ISO-8601 UTC"
  ],
  "references": [
    "structlog: https://www.structlog.org/",
    "12-Factor App - Logs: https://12factor.net/logs",
    "ADR-0004_Deterministic-Content-Addressed-IDs",
    "ADR-0008_Audit-Trail-Timestamps",
    "ADR-0027_DevTools-Page-Architecture"
  ],
  "tags": [
    "observability",
    "logging",
    "debugging",
    "tracing",
    "structlog",
    "devtools",
    "solo-dev"
  ],
  "affected_components": [
    "All Python modules (logging calls)",
    "gateway/main.py (request_id middleware)",
    "shared/workflows/fsm_orchestrator.py (transition logging)",
    "shared/storage/artifact_store.py (write logging)",
    "apps/homepage/frontend/src/devtools/ (trace viewer)"
  ]
}
