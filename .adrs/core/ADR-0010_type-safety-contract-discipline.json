{
  "schema_type": "adr",
  "id": "ADR-0010_type-safety-contract-discipline",
  "title": "Type-Safety & Contract Discipline: Contracts as Tier 0 Foundation",
  "status": "accepted",
  "date": "2025-11-22",
  "deciders": "Mycahya Eggleston",
  "scope": "core",
  "provenance": [
    {
      "at": "2025-11-22",
      "by": "Mycahya Eggleston",
      "note": "Initial draft"
    },
    {
      "at": "2025-01-18",
      "by": "Mycahya Eggleston",
      "note": "Augmented to establish Contracts as Tier 0 in 3-Tier Document Model. Added tier_0_principles to decision_details, updated context/decision to clarify contracts are foundational layer (not just implementation detail). Corrected SPEC references to existing SPEC-0008, SPEC-0009, SPEC-0010, SPEC-0018."
    },
    {
      "at": "2025-12-27",
      "by": "DevTools Editor",
      "note": "Updated via DevTools ADR Editor"
    }
  ],
  "context": "Maintaining strict type safety, schema validation, and contract versioning is a challenge across a rapidly evolving stack (front-end, back-end, Python, API, etc.). Risks include type drift, runtime errors, and contract mismatches between layers. Without a clear hierarchy, documentation (ADRs, Specs, Guides) may duplicate contract definitions, leading to drift between source code and docs. A single source of truth for all data contracts is required—one that serves as the foundational layer (Tier 0) below the 3-Tier Document Model (ADRs, Specs, Guides). Contracts must be executable code (Pydantic models in shared/contracts/), not documentation artifacts. ADRs explain WHY contracts exist, Specs link to contracts to define WHAT we're building, Guides show HOW to use them—but none duplicate contract field definitions. This ADR establishes contracts as Tier 0 and defines the discipline for authoring, versioning, and referencing them across all tiers.",
  "decision_primary": "Contracts (Pydantic models in shared/contracts/) are Tier 0 of the documentation system—the immutable source of truth for all data structures. The 3-Tier Document Model (Tier 1: ADRs, Tier 2: Specs, Tier 3: Guides) references contracts but never duplicates them. All contracts are defined in Pydantic with strict type hints, exported to JSON Schema (auto-generated via tools/gen_json_schema.py), and used to generate OpenAPI specs (via tools/gen_openapi.py). Specs use contract references (module + name + schema_ref), not full field definitions. CI enforces contract drift detection (SPEC-0010), type coverage at 100% via mypy strict mode (SPEC-0010), and versioning discipline (SPEC-0008). All code (backend, shared, tools) uses strict type hints; generated clients (TypeScript) are used for frontend integration (SPEC-0018).",
  "decision_details": {
    "approach": "Pydantic-first contract definition; JSON Schema as the canonical schema (auto-generated, never hand-edited); OpenAPI for API contracts; generated TypeScript clients for frontend; strict type hints everywhere (mypy strict mode + ruff ANN rules).",
    "constraints": [
      "No hand-written schemas or contracts outside Pydantic (shared/contracts/ is source of truth).",
      "All breaking changes require version bumps (semver: __version__ in contract modules per SPEC-0008).",
      "All endpoints and data flows must be covered by type hints and schema validation.",
      "Specs/Guides/ADRs MUST NOT duplicate contract field definitions (use references only per SPEC-0009).",
      "CI blocks merges on contract drift, missing type hints, or tier boundary violations (SPEC-0010)."
    ],
    "implementation_specs": [
      "SPEC-0008_Contract-Discipline-Api-Spec",
      "SPEC-0009_Engineering-Docs-Tenets-Spec",
      "SPEC-0010_Contract-Drift-Type-Coverage-Spec",
      "SPEC-0018_Api-Contract-Validation-and-Drift-Detection"
    ],
    "tier_0_principles": {
      "definition": "Contracts are Tier 0—the foundational layer below ADRs/Specs/Guides. They are executable code (Pydantic models), not documentation artifacts.",
      "single_source_of_truth": "shared/contracts/ is the only place where contract field definitions exist. ADRs/Specs/Guides reference contracts but never duplicate them.",
      "auto_generation": "JSON Schema and OpenAPI specs are auto-generated from Pydantic models (tools/gen_json_schema.py, tools/gen_openapi.py). Hand-editing schemas is forbidden.",
      "tier_separation": "Tier 1 (ADRs) explain WHY contracts exist. Tier 2 (Specs) link to contracts to define WHAT we're building. Tier 3 (Guides) show HOW to use contracts. None duplicate contract field definitions.",
      "ci_enforcement": "CI blocks merges if: (1) Contract drift detected (SPEC-0010), (2) Type coverage < 100% (mypy strict mode), (3) Tier boundary violated (ADR/Spec/Guide duplicates contract fields per SPEC-0009)."
    }
  },
  "consequences": [
    "POSITIVE: Strong type safety and contract discipline across the stack (backend, frontend, docs).",
    "POSITIVE: Reduced risk of runtime errors and contract drift (single source of truth in shared/contracts/).",
    "POSITIVE: Clear hierarchy: Tier 0 (contracts) → Tier 1 (why) → Tier 2 (what) → Tier 3 (how).",
    "POSITIVE: Specs remain concise: Link to contracts instead of duplicating 50+ field definitions.",
    "POSITIVE: Contract changes propagate automatically (no manual doc updates required—CI regenerates schemas).",
    "POSITIVE: Frontend type safety via auto-generated TypeScript clients (SPEC-0018).",
    "POSITIVE: Solo-dev workflow: CI runs on server (Azure DevOps), local execution optional but recommended.",
    "NEGATIVE: Increased up-front effort and CI complexity (mypy strict mode, drift detection scripts, tier boundary validation).",
    "NEGATIVE: All contributors must be familiar with Pydantic, type hinting, and tier boundary rules (learning curve).",
    "NEGATIVE: Initial migration cost: Audit all existing contracts and migrate to Pydantic-first (one-time effort).",
    "NEGATIVE: CI pipeline becomes more complex (multiple validation steps: schema drift, type coverage, tier boundaries).",
    "RISK: Solo-dev context: If CI fails, developer must fix locally before merge (no team to share load).",
    "RISK: Tooling dependency: Requires Pydantic, mypy, ruff, and custom scripts (tools/gen_json_schema.py, tools/gen_openapi.py).",
    "RISK: Breaking changes to contracts require coordinated updates across backend, frontend, and docs (mitigated by semver versioning)."
  ],
  "alternatives_considered": [
    {
      "name": "Hand-written Schemas/Contracts (No Pydantic)",
      "pros": "More flexible, less tooling, no Python dependency. Simpler for non-Python developers (just JSON Schema).",
      "cons": "High risk of drift between code and schemas (no single source of truth). Poor maintainability (manual schema updates on every contract change). No runtime validation (schemas are documentation only). Solo-dev cannot manually sync schemas across 40+ contracts.",
      "rejected_reason": "Fails discipline and reproducibility goals. Solo-dev cannot manually sync schemas across 40+ contracts. No runtime validation means high risk of production bugs."
    },
    {
      "name": "Type Hints Only, No Schema Validation",
      "pros": "Simpler, less boilerplate, no JSON Schema generation. Faster development (no schema generation step).",
      "cons": "No runtime validation (type hints are static only). Weak contracts (no enforcement at API boundaries). Frontend has no type safety (no OpenAPI-generated clients). API clients must hand-write types (high risk of drift).",
      "rejected_reason": "Insufficient for robust systems. Frontend TypeScript integration requires OpenAPI-generated clients (SPEC-0018). No runtime validation means high risk of production bugs."
    },
    {
      "name": "Contracts as Documentation (Tier 2 Specs)",
      "pros": "All contract info in one place (specs), no need to navigate to shared/contracts/. Easier for non-developers to understand (no code reading required).",
      "cons": "Massive duplication (50+ fields per contract × 40+ contracts = 2000+ lines of duplicated definitions). High risk of drift (specs and code diverge over time). Specs become unreadable (1000+ lines per spec). CI cannot detect drift (no source of truth—two conflicting definitions).",
      "rejected_reason": "Violates single source of truth principle (SPEC-0009). Specs would duplicate shared/contracts/, creating two conflicting definitions. Solo-dev cannot manually keep them in sync."
    },
    {
      "name": "Contracts as Tier 1 (ADRs)",
      "pros": "Contracts documented alongside architectural decisions. Single file contains both 'why' and 'what'.",
      "cons": "ADRs answer 'why', not 'what' (violates tier separation per SPEC-0009). Mixing contract definitions with decision rationale violates tier boundary rules. ADRs would become 1000+ lines (unreadable). Contracts are executable code, not decision records.",
      "rejected_reason": "Violates tier boundary rules (SPEC-0009). Contracts are executable code (Pydantic models), not decision records. ADRs would become unreadable."
    }
  ],
  "tradeoffs": "Higher up-front investment in tooling and discipline (mypy strict mode, ruff ANN rules, drift detection scripts, tier boundary validation), but much lower risk of bugs and contract mismatches. Some learning curve for contributors (Pydantic, type hints, tier boundaries). Solo-dev context: Initial setup cost is one-time, ongoing maintenance is minimal (CI automates validation). Trade-off is worth it for long-term maintainability and type safety.",
  "rollout_plan": [
    "Phase 1: Audit all existing contracts and migrate to Pydantic-first (shared/contracts/dat/*.py).",
    "Phase 2: Integrate JSON Schema export (tools/gen_json_schema.py) and OpenAPI generation (tools/gen_openapi.py) into CI.",
    "Phase 3: Add contract drift/type coverage checks to CI (ci/steps/step_schema_drift.ps1, ci/steps/step_mypy.ps1).",
    "Phase 4: Update all specs to use contract references (module + name + schema_ref) instead of inline definitions.",
    "Phase 5: Add tier boundary validation to CI (ci/steps/step_docs_validate.ps1) to prevent contract duplication in ADRs/Specs/Guides.",
    "Phase 6: Update README and SPEC-0009 to document Tier 0 principles.",
    "Phase 7: Train contributors on new workflow (solo-dev: self-training via guides in docs/guides/developer/)."
  ],
  "rollback_plan": "Revert to previous contract definition and validation approach (not recommended). Would require: (1) Remove mypy strict mode from CI, (2) Remove drift detection scripts (ci/steps/step_schema_drift.ps1), (3) Allow hand-written schemas (remove auto-generation), (4) Remove tier boundary enforcement (ci/steps/step_docs_validate.ps1). High risk of reintroducing drift and type safety issues. Rollback should only be considered if tooling becomes unmaintainable (unlikely in solo-dev context).",
  "metrics_to_watch": [
    "% of endpoints/data flows covered by Pydantic models and type hints (target: 100% per SPEC-0010).",
    "Number of contract drift/type coverage CI failures (target: 0 after initial migration).",
    "Number of tier boundary violations detected by CI (target: 0 per SPEC-0009).",
    "Time to add new contract (should decrease as tooling matures).",
    "Developer onboarding/feedback (solo-dev: self-assessment of workflow friction).",
    "Number of production bugs caused by type mismatches (target: 0)."
  ],
  "guardrails": [
    {
      "rule": "All contracts must be defined in Pydantic (shared/contracts/) and exported to JSON Schema (auto-generated via tools/gen_json_schema.py).",
      "enforcement": "CI must block merges if contract drift or missing type hints are detected (ci/steps/step_schema_drift.ps1, ci/steps/step_mypy.ps1 per SPEC-0010).",
      "scope": "core",
      "references": [
        "SPEC-0008_Contract-Discipline-Api-Spec",
        "SPEC-0010_Contract-Drift-Type-Coverage-Spec"
      ],
      "id": "contracts-defined-pydantic-shared-contracts"
    },
    {
      "rule": "Specs/Guides/ADRs MUST NOT duplicate contract field definitions. Use references only (module + name + schema_ref).",
      "enforcement": "CI tier boundary validation (ci/steps/step_docs_validate.ps1) fails if 'contract_definitions' field found in ADR/Spec/Guide per SPEC-0009.",
      "scope": "core",
      "references": [
        "SPEC-0009_Engineering-Docs-Tenets-Spec"
      ],
      "id": "specs-guides-adrs-not-duplicate"
    },
    {
      "rule": "All Pydantic models must have 100% type hint coverage (parameters, return values, class attributes).",
      "enforcement": "CI mypy strict mode + ruff ANN rules (ci/steps/step_mypy.ps1, ci/steps/step_ruff.ps1 per SPEC-0010).",
      "scope": "core",
      "references": [
        "SPEC-0010_Contract-Drift-Type-Coverage-Spec"
      ],
      "id": "pydantic-models-have-100-type"
    }
  ],
  "cross_cutting_guardrails": [
    "Contract Versioning: All breaking changes require version bumps (see ADR-0045#contract-versioning)",
    "Deterministic Artifacts: All generated schemas/clients must be reproducible (see ADR-0045#deterministic-artifacts)"
  ],
  "references": [
    "ADR-0015_3-Tier-Document-Model: Tier 0 contracts foundation for doc hierarchy",
    "ADR-0016_Hybrid-Semver-Contract-Versioning: Contract versioning strategy",
    "ADR-0017_Cross-Cutting-Guardrails: Contract discipline guardrails",
    "shared/contracts/: All Pydantic contracts for DAT, PPTX, SOV tools",
    "SPEC-0008_Contract-Discipline-Api-Spec",
    "SPEC-0009_Engineering-Docs-Tenets-Spec",
    "SPEC-0010_Contract-Drift-Type-Coverage-Spec"
  ],
  "tags": [
    "type-safety",
    "schema-validation",
    "contract-versioning",
    "pydantic",
    "tier-0",
    "contracts"
  ],
  "affected_components": [
    "all data models",
    "api layer",
    "ci pipeline",
    "developer workflow",
    "shared/contracts/",
    "tools/gen_json_schema.py",
    "tools/gen_openapi.py"
  ],
  "review_date": "2026-05-22"
}