{
  "schema_type": "adr",
  "id": "ADR-0013_cross-platform-concurrency",
  "title": "Cross-Platform Concurrency: Unified Async, Threading, and Process Parallelism for All OS",
  "status": "accepted",
  "date": "2025-11-22",
  "deciders": "Mycahya Eggleston",
  "scope": "core",
  "provenance": [
    {
      "at": "2025-11-22",
      "by": "Mycahya Eggleston",
      "note": "Initial draft (Windows-First focus)"
    },
    {
      "at": "2025-12-27",
      "by": "Mycahya Eggleston",
      "note": "Refactored to true cross-platform approach supporting Windows, macOS, and Linux equally with unified concurrency abstraction"
    }
  ],
  "context": "All engineering tools (DAT, PPTX Generator, SOV Analyzer) require reliable, deterministic, and fully cross-platform concurrency across Windows, macOS, and Linux. Users and developers work on diverse operating systems with different shells (Bash, Zsh, PowerShell, CMD) and different process models (fork on Unix, spawn on Windows). The platform must support three concurrency patterns: (1) async/await for I/O-bound operations, (2) thread pools for concurrent I/O, (3) process pools for CPU-bound parallelism. Raw multiprocessing/threading is error-prone due to platform differences in process spawning, signal handling, and resource management. A unified abstraction layer is needed to provide consistent behavior regardless of OS or shell.",
  "decision_primary": "Adopt a three-tier concurrency model with OS-aware execution: (1) asyncio for I/O-bound async operations (fully cross-platform), (2) concurrent.futures.ThreadPoolExecutor for concurrent I/O with configurable caps, (3) concurrent.futures.ProcessPoolExecutor with spawn start method for CPU-bound parallelism. All concurrency flows through shared/concurrent/ abstraction which auto-detects OS and configures appropriate backends. Shell commands use subprocess with shell=False and explicit executable paths resolved via shutil.which(). CI runs all tests on Windows, macOS, and Linux.",
  "decision_details": {
    "approach": "Three-tier concurrency with OS-aware abstraction layer in shared/concurrent/. Tier 1 (Async): asyncio event loops for non-blocking I/O. Tier 2 (Threads): ThreadPoolExecutor for concurrent blocking I/O (file reads, network). Tier 3 (Processes): ProcessPoolExecutor with spawn start method for CPU-bound work. All tiers accessed via unified API that handles OS detection, resource caps, and deterministic seeding.",
    "os_detection": {
      "mechanism": "sys.platform and platform.system() at module load time",
      "windows": "spawn is default, no changes needed for ProcessPoolExecutor",
      "macos_linux": "Explicitly set multiprocessing.set_start_method('spawn', force=True) at app startup to match Windows behavior",
      "rationale": "spawn is slower but safer and consistent across all platforms; fork can cause deadlocks with threads"
    },
    "shell_execution": {
      "rule": "Never use shell=True in subprocess calls",
      "command_resolution": "Use shutil.which() to find executable paths cross-platform",
      "powershell": "Detect via shutil.which('pwsh') or shutil.which('powershell')",
      "bash_zsh": "Detect via shutil.which('bash') or shutil.which('zsh')",
      "cmd": "Detect via os.environ.get('COMSPEC') on Windows",
      "fallback": "Use Python-native solutions (pathlib, shutil) when possible instead of shell commands"
    },
    "constraints": [
      "No raw multiprocessing.Process or threading.Thread - use concurrent.futures or asyncio.",
      "All ProcessPoolExecutor usage MUST use spawn start method (set globally at app startup).",
      "Thread/process caps configurable via environment variables (default: CPU count for processes, 4x CPU for threads).",
      "Deterministic seeding required: pass explicit seed to workers, never rely on global random state.",
      "All subprocess calls MUST use shell=False with explicit executable path.",
      "CI MUST run concurrency tests on Windows, macOS, AND Linux."
    ],
    "api_surface": {
      "run_async": "async def run_async(coro) - Run coroutine with proper event loop handling",
      "run_in_threads": "def run_in_threads(fn, items, max_workers=None) - Map function over items with ThreadPoolExecutor",
      "run_in_processes": "def run_in_processes(fn, items, max_workers=None, seed=42) - Map function over items with ProcessPoolExecutor (spawn)",
      "run_shell_command": "def run_shell_command(args, cwd=None) - Execute command with auto-detected shell, shell=False",
      "get_platform_info": "def get_platform_info() -> PlatformInfo - Return OS, shell, and concurrency capabilities"
    },
    "implementation_specs": [
      "SPEC-0011_Concurrency-Determinism-Spec",
      "SPEC-0019_Cross-Platform-Shell-Execution-Spec"
    ],
    "tier_0_contracts": [
      "shared/contracts/core/concurrency.py: PlatformInfo, ConcurrencyConfig, OSType, ShellType, ConcurrencyTier, get_platform_info()"
    ]
  },
  "consequences": [
    "Concurrency is reliable and deterministic across Windows, macOS, and Linux.",
    "All platforms are first-class citizens - same behavior on all OS.",
    "Developers can use any shell (Bash, Zsh, PowerShell, CMD) without code changes.",
    "Slightly higher latency for process pools due to spawn (vs fork) on Unix.",
    "Up-front effort to build cross-platform abstraction layer.",
    "Existing code using raw multiprocessing/threading requires refactoring."
  ],
  "alternatives_considered": [
    {
      "name": "Raw Multiprocessing/Threading",
      "pros": "Familiar to many developers, minimal abstraction.",
      "cons": "Platform-specific behavior (fork vs spawn), hard to enforce determinism, error-prone.",
      "rejected_reason": "Fails reliability and cross-platform goals."
    },
    {
      "name": "Platform-Specific Code Paths",
      "pros": "Optimal performance per platform, use fork on Unix for speed.",
      "cons": "Maintenance burden, divergent behavior, harder to test.",
      "rejected_reason": "Consistency and maintainability outweigh marginal performance gains."
    },
    {
      "name": "Single Platform Target (Linux-Only or Windows-Only)",
      "pros": "Simpler CI, no platform abstraction needed.",
      "cons": "Excludes users/developers on other platforms.",
      "rejected_reason": "Not acceptable for a cross-platform project with diverse user base."
    },
    {
      "name": "Third-Party Libraries (joblib, dask, ray)",
      "pros": "Battle-tested, feature-rich, handles many edge cases.",
      "cons": "Heavy dependencies, learning curve, may be overkill for our needs.",
      "rejected_reason": "Considered for future if needs grow; current abstraction is sufficient and lighter."
    }
  ],
  "tradeoffs": "Choosing spawn over fork on Unix adds ~50-100ms latency per process pool creation but ensures identical behavior across all platforms. The abstraction layer adds a small learning curve but eliminates platform-specific bugs. Shell command abstraction may be slower than native shell but is safer and portable.",
  "rollout_plan": [
    "Create shared/concurrent/ module with cross-platform abstraction layer.",
    "Add multiprocessing.set_start_method('spawn', force=True) to all entry points.",
    "Audit all existing concurrency usage and migrate to new API.",
    "Replace all subprocess shell=True calls with shell=False and explicit paths.",
    "Expand CI matrix to include Windows, macOS, and Linux.",
    "Document concurrency patterns and shell execution in developer guide."
  ],
  "rollback_plan": "Revert to previous concurrency approach (not recommended).",
  "metrics_to_watch": [
    "CI pass rate across all platforms (Windows, macOS, Linux).",
    "Incidents of platform-specific or non-deterministic bugs.",
    "Percentage of code using shared/concurrent/ API.",
    "Process pool latency on Unix (should be <200ms overhead)."
  ],
  "guardrails": [
    {
      "rule": "All concurrency must use shared/concurrent/ abstraction - no raw multiprocessing.Process or threading.Thread.",
      "enforcement": "CI lint rule blocks imports of raw multiprocessing.Process or threading.Thread outside shared/concurrent/.",
      "scope": "core",
      "id": "concurrency-use-abstraction"
    },
    {
      "rule": "All subprocess calls must use shell=False with explicit executable path.",
      "enforcement": "CI lint rule blocks subprocess.run/Popen calls with shell=True.",
      "scope": "core",
      "id": "subprocess-no-shell-true"
    },
    {
      "rule": "ProcessPoolExecutor must use spawn start method on all platforms.",
      "enforcement": "App entry points call multiprocessing.set_start_method('spawn', force=True); CI verifies.",
      "scope": "core",
      "id": "process-pool-spawn-only"
    },
    {
      "rule": "CI must pass on Windows, macOS, AND Linux for any concurrency-related changes.",
      "enforcement": "GitHub Actions matrix includes all three platforms; merge blocked if any fail.",
      "scope": "core",
      "id": "ci-all-platforms"
    }
  ],
  "cross_cutting_guardrails": [
    "Deterministic Artifacts: All parallel operations must be reproducible (see ADR-0045#concurrency)",
    "Path Safety: All shell commands must use normalized paths (see ADR-0045#path-safety)"
  ],
  "references": [
    "ADR-0017_Cross-Cutting-Guardrails#concurrency: Cross-cutting concurrency guardrail",
    "ADR-0004_Deterministic-Content-Addressed-IDs: Deterministic seeding for reproducibility",
    "shared/concurrent/: Cross-platform concurrency API",
    "Python docs: concurrent.futures (https://docs.python.org/3/library/concurrent.futures.html)",
    "Python docs: asyncio (https://docs.python.org/3/library/asyncio.html)",
    "Python docs: multiprocessing start methods (https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods)",
    "ADR-0015",
    "ADR-0041"
  ],
  "tags": [
    "concurrency",
    "cross-platform",
    "async",
    "threading",
    "multiprocessing",
    "windows",
    "macos",
    "linux",
    "determinism"
  ],
  "affected_components": [
    "concurrency abstractions",
    "ci pipeline",
    "developer workflow"
  ],
  "review_date": "2026-05-22"
}