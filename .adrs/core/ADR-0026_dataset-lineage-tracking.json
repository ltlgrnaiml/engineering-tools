{
  "schema_type": "adr",
  "id": "ADR-0026_dataset-lineage-tracking",
  "title": "Cross-Tool DataSet Lineage, Provenance, and Version Tracking",
  "status": "accepted",
  "date": "2024-12-27",
  "review_date": "2025-06-27",
  "deciders": "Mycahya Eggleston",
  "scope": "core",
  "provenance": [
    {
      "at": "2024-12-27",
      "by": "AI Analysis",
      "note": "Initial draft based on platform DataSet requirements"
    },
    {
      "at": "2025-12-27",
      "by": "DevTools Editor",
      "note": "Updated via DevTools ADR Editor"
    },
    {
      "at": "2025-12-28",
      "by": "Mycahya Eggleston",
      "note": "EXTENDED: Added data versioning support with version_id (content hash), parent_version_id for lineage, and conflict detection via hash comparison"
    }
  ],
  "context": "As data flows through multiple tools (DAT → SOV → PPTX), tracking lineage becomes critical for debugging, reproducibility, and compliance. Each DataSet should know its origin: which tool created it, which input DataSet(s) it derived from, and what transformation was applied. Additionally, DataSets may be modified over time, requiring version tracking to identify which version of a DataSet was used as input. The challenge is designing a lineage model that is simple enough for common cases (single parent) while supporting complex cases (multiple parents, external sources) and version evolution.",
  "decision_primary": "All DataSets track lineage via parent_ref, source_tool, and version_id fields in DataSetManifest. parent_ref is the ID of the input DataSet (nullable for root datasets from external sources). source_tool is an enum indicating which tool created the DataSet (dat, sov, pptx, external). version_id is the SHA-256 hash of the DataSet content, enabling content-addressable versioning. parent_version_id links to the specific version of the parent DataSet used. Lineage is immutable once created. The gateway provides a /lineage endpoint to retrieve the full lineage graph for any DataSet, including version history.",
  "decision_details": {
    "approach": "Manifest-based lineage with parent_ref, source_tool, version_id, and parent_version_id fields. Gateway aggregates lineage graph by walking parent_ref chain. External sources have null parent_ref and source_tool='external'. Content hashing enables version identification and conflict detection.",
    "constraints": [
      "DataSetManifest MUST include parent_ref field (nullable for root datasets)",
      "DataSetManifest MUST include source_tool enum: dat, sov, pptx, external",
      "DataSetManifest MUST include version_id (SHA-256 hash of content)",
      "DataSetManifest MUST include parent_version_id when parent_ref is set",
      "Lineage is immutable (parent_ref, version_id cannot be modified after creation)",
      "Circular lineage references MUST be rejected (validation at save time)",
      "Gateway /lineage endpoint returns full ancestor chain with version history",
      "Multi-parent lineage (joins) uses parent_refs array (future extension)",
      "Conflicting edits detected via content hash comparison"
    ],
    "versioning_model": {
      "version_id": {
        "description": "SHA-256 hash of DataSet Parquet content",
        "purpose": "Content-addressable identification; same content = same version_id",
        "computation": "hashlib.sha256(parquet_bytes).hexdigest()"
      },
      "parent_version_id": {
        "description": "version_id of the parent DataSet at time of derivation",
        "purpose": "Captures exact version used as input; enables reproducibility",
        "validation": "Must match an existing version_id in parent DataSet history"
      },
      "version_history": {
        "description": "List of all version_ids for a DataSet over time",
        "storage": "Stored in DataSet directory as versions.json",
        "structure": "[{version_id, created_at, parent_version_id}, ...]"
      },
      "conflict_detection": {
        "scenario": "Two processes modify same DataSet concurrently",
        "detection": "On save, compare expected parent_version_id with current; mismatch = conflict",
        "resolution": "Reject save with conflict error; user must resolve manually"
      }
    },
    "implementation_specs": [
      "SPEC-0028_DataSet-Lineage-Spec",
      "SPEC-0007",
      "SPEC-0008"
    ]
  },
  "consequences": [
    "✅ POSITIVE: Full provenance tracking across tool boundaries",
    "✅ POSITIVE: Debugging simplified (can trace data origin and exact version)",
    "✅ POSITIVE: Compliance supported (audit trail of data transformations)",
    "✅ POSITIVE: Immutability prevents lineage tampering",
    "✅ POSITIVE: Content-addressable versioning enables exact reproducibility",
    "✅ POSITIVE: Conflict detection prevents silent data overwrites",
    "❌ NEGATIVE: Lineage queries may be slow for deep graphs (mitigated by caching)",
    "❌ NEGATIVE: Version history grows over time (mitigated by retention policy)",
    "⚠️ NEUTRAL: Multi-parent lineage adds complexity (deferred to future extension)"
  ],
  "alternatives_considered": [
    {
      "name": "No Lineage Tracking",
      "pros": "Simpler, no manifest changes",
      "cons": "Cannot trace data origin, debugging is difficult",
      "rejected_reason": "Fails compliance and debugging requirements"
    },
    {
      "name": "Separate Lineage Database",
      "pros": "Query flexibility, graph database benefits",
      "cons": "Adds database dependency, sync complexity",
      "rejected_reason": "Manifest-based lineage is simpler and sufficient"
    },
    {
      "name": "Full Provenance Graph (All Ancestors Embedded)",
      "pros": "Single read for full lineage",
      "cons": "Manifests grow unbounded, duplication",
      "rejected_reason": "Parent-only lineage is compact; graph computed on demand"
    }
  ],
  "tradeoffs": "We trade query performance (walking parent chain) for storage efficiency (no duplication). Immutability prevents tampering but blocks corrections. Single-parent model is simple but defers multi-parent joins.",
  "guardrails": [
    {
      "rule": "DataSetManifest MUST include parent_ref for derived datasets",
      "enforcement": "ArtifactStore validates non-null parent_ref when source_tool != 'external'",
      "scope": "core",
      "id": "dataset-lineage-parent-ref-required"
    },
    {
      "rule": "Circular lineage references MUST be rejected",
      "enforcement": "ArtifactStore walks parent chain at save time; rejects cycles",
      "scope": "core",
      "id": "dataset-lineage-no-cycles"
    }
  ],
  "cross_cutting_guardrails": [
    "Audit Trail: All lifecycle events must be logged (see ADR-0045#audit-trail)"
  ],
  "references": [
    "ADR-0004_Deterministic-Content-Addressed-IDs: IDs enable lineage tracking",
    "ADR-0001_Guided-Workflow-FSM-Orchestration: Workflows produce DataSets with lineage",
    "shared/contracts/core/dataset.py: DataSetManifest schema",
    "shared/storage/artifact_store.py: Lineage validation on save",
    "gateway/services/dataset_service.py: Lineage query endpoint"
  ],
  "tags": [
    "dataset",
    "lineage",
    "provenance",
    "cross-tool"
  ],
  "affected_components": [
    "shared/contracts/core/dataset.py",
    "shared/storage/artifact_store.py",
    "gateway/services/dataset_service.py"
  ]
}