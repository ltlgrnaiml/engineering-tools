{
  "schema_type": "adr",
  "id": "ADR-0002_Artifact-Preservation-on-Unlock",
  "title": "Artifact Preservation on Unlock for All CDU-DAT Pipeline Stages",
  "status": "accepted",
  "date": "2025-01-15",
  "review_date": "2025-07-15",
  "deciders": "Mycahya Eggleston",
  "scope": "subsystem:CDU-DAT",
  "provenance": [
    {
      "at": "2025-01-15",
      "by": "Mycahya Eggleston",
      "note": "Initial decision extracted from stage orchestration vision document"
    },
    {
      "at": "2025-11-22",
      "by": "Mycahya Eggleston",
      "note": "Refactored for explicit coverage of all pipeline stages, including Export, and clarified audit trail and idempotent re-lock"
    }
  ],
  "context": "CDU-DAT users invest significant effort in manual edits and curation across all pipeline stages (Selection, Context, Table Selection, Preview, Parse, Export). Accidental unlocks or iterative refinement should not result in loss of user work. The system must preserve all artifacts on unlock, support idempotent re-locks, and maintain a full audit trail for compliance and debugging. This policy applies to all stages, including Export.",
  "decision_primary": "When any pipeline stage is unlocked, set locked:false in the artifact metadata and preserve the artifact file on disk. Never delete artifacts, even when unlocks cascade downstream. Add an unlocked_at timestamp to the artifact's meta section. On re-lock, if the artifact exists with the same stage ID, reuse it (idempotent re-lock). This applies to all stages, including Export.",
  "decision_details": {
    "approach": "Soft unlock with artifact preservation. Unlock operation sets locked:false and adds unlocked_at in artifact metadata. Artifact files remain on disk under the run directory. Re-lock checks for existing artifact with the same stage ID and reuses it if present. Cascade unlocks preserve all downstream artifacts (locked:false for all).",
    "constraints": [
      "Must preserve user edits and curation at all stages.",
      "Must enable accidental unlock recovery (re-lock with same inputs reuses artifact).",
      "Must maintain audit trail (all snapshots remain readable for debugging/compliance).",
      "Must support idempotent re-lock (same inputs yield same stage ID and artifact reuse).",
      "No automatic cleanup; manual cleanup or future garbage collection may be added."
    ],
    "implementation_specs": [
      "SPEC-0013_Artifact-Lifecycle-Preservation-Spec",
      "SPEC-0012_Audit-Trail-Enforcement-Spec"
    ]
  },
  "consequences": [
    "Accidental unlock recovery: Users can re-lock without losing work if inputs are unchanged.",
    "Audit trails: All snapshots remain readable for debugging and compliance.",
    "Idempotent re-lock: Same inputs yield same stage ID and artifact reuse (no re-computation).",
    "User confidence: Users can experiment with unlocks without fear of data loss.",
    "Disk usage grows: Artifacts accumulate with locked:false (not garbage collected).",
    "Stale artifacts: Users might re-lock with different inputs, creating orphaned artifacts.",
    "No automatic cleanup: Requires manual cleanup or future garbage collection feature."
  ],
  "alternatives_considered": [
    {
      "name": "Delete Artifacts on Unlock",
      "pros": "Clean disk usage, simple implementation.",
      "cons": "Loses user work on accidental unlock, no recovery mechanism, users lose confidence.",
      "rejected_reason": "Unacceptable user experience; users would lose expensive manual edits on accidental unlock."
    },
    {
      "name": "Copy-on-Write Snapshots",
      "pros": "Preserves all versions, full history for rollback.",
      "cons": "Disk bloat, complex snapshot management, unclear UX.",
      "rejected_reason": "Overkill for local desktop tool; disk bloat is worse than soft unlock."
    },
    {
      "name": "Confirmation Dialog on Unlock",
      "pros": "Prevents accidental unlocks, no artifact preservation needed.",
      "cons": "Annoying UX, doesn't solve intentional unlock + re-lock scenario.",
      "rejected_reason": "Doesn't address intentional unlock scenarios; only adds friction."
    }
  ],
  "tradeoffs": "We trade disk usage (artifacts accumulate with locked:false) for user effort preservation (accidental unlock recovery). We accept the need for future garbage collection to gain user confidence and compliance.",
  "guardrails": [
    {
      "rule": "Artifact Preservation: Unlocking a stage MUST set locked:false but NEVER delete artifact file.",
      "enforcement": "Unlock operation sets locked:false in artifact metadata; file remains on disk.",
      "scope": "subsystem:CDU-DAT"
    },
    {
      "rule": "Cascade Preservation: Cascade unlocks MUST preserve all downstream artifacts (locked:false).",
      "enforcement": "Global orchestrator sets locked:false for all dependent downstream stages.",
      "scope": "subsystem:CDU-DAT"
    },
    {
      "rule": "Idempotent Re-lock: Re-lock with same inputs MUST reuse existing artifact (same stage ID).",
      "enforcement": "Backend checks for existing artifact with same stage ID before recomputing.",
      "scope": "subsystem:CDU-DAT"
    },
    {
      "rule": "Metadata Integrity: unlocked_at timestamp MUST be added to meta section on unlock.",
      "enforcement": "Unlock operation updates artifact metadata with unlocked_at.",
      "scope": "subsystem:CDU-DAT",
      "id": "metadata-integrity-timestamp-added-meta"
    }
  ],
  "cross_cutting_guardrails": [
    "Path Safety: All public paths must be relative (see ADR-0017#path-safety)",
    "Idempotency: All mutating requests must be idempotent or safely retryable (see .adrs/cross-cutting/GUARDRAILS.md#idempotency)"
  ],
  "references": [
    "ADR-0001_Hybrid-FSM-Stage-Orchestration",
    "ADR-0004_Deterministic-Stage-IDs",
    "GUARDRAILS"
  ],
  "tags": [
    "artifact-preservation",
    "user-experience",
    "data-integrity",
    "idempotency",
    "audit-trail"
  ],
  "affected_components": [
    "backend/src/dramcdu/dat_aggregation/core/state_machine.py",
    "backend/src/dramcdu/dat_aggregation/core/snapshot_manager.py",
    "runs/<run_id>.mmrun/*.json"
  ]
}
