{
  "schema_type": "spec",
  "id": "SPEC-0007_dataset-lineage",
  "title": "DataSet Lineage and Version Tracking Specification",
  "version": "2025.12.001",
  "status": "active",
  "date": "2025-12-28",
  "author": "Mycahya Eggleston",
  "implements_adr": [
    "ADR-0025_DataSet-Lineage-Tracking",
    "ADR-0026"
  ],
  "changelog": [
    {
      "version": "2025.12.001",
      "date": "2025-12-28",
      "change": "EXTENDED: Added version_id (SHA-256 content hash) and parent_version_id for content-addressable versioning per ADR-0026 extension"
    }
  ],
  "tier_0_contracts": [
    {
      "module": "shared.contracts.core.dataset",
      "classes": [
        "DataSetManifest",
        "DataSetRef",
        "ColumnMeta",
        "LineageRecord",
        "VersionRecord"
      ]
    }
  ],
  "purpose": "Define how datasets track their lineage AND versions across tools. When DAT produces a dataset consumed by SOV, or SOV results feed into PPTX, the lineage chain is preserved for auditability and reproducibility. Content-addressable versioning enables exact reproducibility by tracking which version of parent data was used.",
  "scope": "core",
  "requirements": [
    {
      "id": "REQ-LINEAGE-001",
      "description": "Every DataSet MUST have a unique dataset_id",
      "format": "SHA-256 hash of source + schema + timestamp",
      "reference": "ADR-0005"
    },
    {
      "id": "REQ-LINEAGE-002",
      "description": "DataSet manifests MUST include parent_refs for lineage",
      "implementation": "DataSetRef list in manifest pointing to upstream datasets"
    },
    {
      "id": "REQ-LINEAGE-003",
      "description": "Column-level lineage MUST track transformations",
      "implementation": "ColumnMeta.source_columns field"
    },
    {
      "id": "REQ-LINEAGE-004",
      "description": "Cross-tool handoffs MUST preserve lineage chain",
      "flows": [
        "DAT → SOV",
        "DAT → PPTX",
        "SOV → PPTX"
      ]
    },
    {
      "id": "REQ-LINEAGE-005",
      "description": "Lineage queries MUST support forward and backward traversal",
      "implementation": "get_upstream(dataset_id), get_downstream(dataset_id)"
    },
    {
      "id": "REQ-VERSION-001",
      "description": "Every DataSet MUST have a version_id (SHA-256 hash of Parquet content)",
      "implementation": "hashlib.sha256(parquet_bytes).hexdigest()",
      "purpose": "Content-addressable identification; same content = same version_id"
    },
    {
      "id": "REQ-VERSION-002",
      "description": "DataSet manifests MUST include parent_version_id when parent_ref is set",
      "implementation": "Captures exact version of parent used; enables reproducibility"
    },
    {
      "id": "REQ-VERSION-003",
      "description": "Version history MUST be maintained for each DataSet",
      "implementation": "versions.json file in DataSet directory",
      "format": "[{version_id, created_at, parent_version_id}, ...]"
    },
    {
      "id": "REQ-VERSION-004",
      "description": "Conflicting edits MUST be detected via content hash comparison",
      "implementation": "On save, compare expected parent_version_id with current; mismatch = conflict"
    }
  ],
  "dataset_manifest": {
    "required_fields": [
      "dataset_id",
      "version_id",
      "created_at",
      "created_by_tool",
      "schema_version",
      "columns",
      "row_count",
      "parent_refs",
      "parent_version_id"
    ],
    "optional_fields": [
      "description",
      "tags",
      "quality_metrics",
      "sample_data"
    ]
  },
  "versioning_model": {
    "version_id": {
      "description": "SHA-256 hash of DataSet Parquet content",
      "computation": "hashlib.sha256(parquet_bytes).hexdigest()",
      "property": "Content-addressable: same content always produces same version_id"
    },
    "parent_version_id": {
      "description": "version_id of parent DataSet at time of derivation",
      "validation": "Must match existing version_id in parent DataSet history",
      "nullable": true,
      "nullable_when": "Root datasets with no parent"
    },
    "version_history": {
      "storage": "versions.json in DataSet directory",
      "schema": {
        "type": "array",
        "items": {
          "version_id": "string (SHA-256)",
          "created_at": "string (ISO-8601 UTC)",
          "parent_version_id": "string | null"
        }
      }
    },
    "conflict_detection": {
      "scenario": "Two processes modify same DataSet concurrently",
      "mechanism": "Compare expected parent_version_id with current latest",
      "on_mismatch": "Reject save with ConflictError",
      "resolution": "Manual: user must review and decide which version to keep"
    }
  },
  "lineage_graph": {
    "nodes": "DataSet manifests (with version_id)",
    "edges": "parent_refs + parent_version_id → child relationships",
    "traversal": [
      "Breadth-first for impact analysis",
      "Depth-first for root cause"
    ],
    "visualization": "DAG rendering in DevTools with version annotations"
  },
  "cross_tool_flows": {
    "DAT_to_SOV": {
      "source": "DAT Export stage produces Parquet + manifest with version_id",
      "handoff": "SOV Load stage reads manifest, captures version_id as parent_version_id",
      "lineage": "SOV results include DAT dataset_id AND version_id in lineage"
    },
    "DAT_to_PPTX": {
      "source": "DAT Export stage produces Parquet + manifest with version_id",
      "handoff": "PPTX Data stage reads manifest, captures version_id",
      "lineage": "PPTX generation includes DAT dataset_id + version_id in audit trail"
    },
    "SOV_to_PPTX": {
      "source": "SOV Analyze stage produces results + manifest with version_id",
      "handoff": "PPTX binds SOV visualization specs to chart shapes",
      "lineage": "PPTX includes SOV analysis_id + version_id in audit trail"
    }
  },
  "api_endpoints": {
    "get_lineage": "GET /api/datasets/{dataset_id}/lineage",
    "get_version_history": "GET /api/datasets/{dataset_id}/versions",
    "get_specific_version": "GET /api/datasets/{dataset_id}/versions/{version_id}"
  },
  "references": [
    "ADR-0025_DataSet-Lineage-Tracking: WHY we track lineage and versions",
    "ADR-0004_Deterministic-Content-Addressed-IDs: HOW datasets and versions are identified",
    "shared/contracts/core/dataset.py: Tier-0 contracts"
  ]
}