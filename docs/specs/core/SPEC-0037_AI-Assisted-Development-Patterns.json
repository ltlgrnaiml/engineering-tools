{
  "schema_type": "spec",
  "id": "SPEC-0037",
  "title": "AI-Assisted Development Patterns Specification",
  "version": "2025.12.001",
  "status": "active",
  "implements": "ADR-0033",
  "date": "2025-12-28",
  "scope": "core",
  "summary": "Technical specification for AI-parseable code patterns including file naming, function naming, docstring format, comment philosophy, directory structure, and import organization.",
  "tier_0_contracts": [],
  "file_naming": {
    "pattern": "{domain}_{action}.py",
    "regex": "^[a-z]+(_[a-z]+)+\\.py$",
    "examples": {
      "correct": [
        "dataset_loader.py",
        "stage_orchestrator.py",
        "artifact_store.py",
        "manifest_validator.py",
        "chart_renderer.py"
      ],
      "incorrect": [
        "DataSetLoader.py",
        "loader.py",
        "utils.py",
        "helpers.py",
        "misc.py"
      ]
    },
    "enforcement": {
      "tool": "Custom linter rule (future)",
      "ci_check": "File naming validation in pre-commit"
    }
  },
  "function_naming": {
    "pattern": "{verb}_{noun}",
    "regex": "^(load|save|fetch|store|read|write|parse|render|convert|transform|format|validate|check|verify|ensure|assert|create|delete|update|initialize|dispose|calculate|compute|derive|aggregate|summarize|get|find|list|search|filter)_[a-z_]+$",
    "verb_categories": {
      "data_access": ["load", "save", "fetch", "store", "read", "write"],
      "transformation": ["parse", "render", "convert", "transform", "format"],
      "validation": ["validate", "check", "verify", "ensure", "assert"],
      "lifecycle": ["create", "delete", "update", "initialize", "dispose"],
      "computation": ["calculate", "compute", "derive", "aggregate", "summarize"],
      "queries": ["get", "find", "list", "search", "filter"]
    },
    "examples": {
      "correct": [
        "load_dataset()",
        "render_chart()",
        "validate_manifest()",
        "create_artifact()",
        "calculate_variance()"
      ],
      "incorrect": [
        "dataset()",
        "do_chart()",
        "process()",
        "handle()",
        "run()"
      ]
    }
  },
  "docstring_format": {
    "style": "Google",
    "required_sections": ["Summary", "Args", "Returns", "Raises"],
    "optional_sections": ["Example", "Note", "Warning", "See Also"],
    "template": "\"\"\"One-line summary of function purpose.\n\nOptional extended description.\n\nArgs:\n    param_name: Description of parameter.\n    another_param: Description with type if not obvious.\n\nReturns:\n    Description of return value.\n\nRaises:\n    ExceptionType: When this exception is raised.\n\nExample:\n    >>> result = function_name(arg1, arg2)\n    >>> print(result)\n    expected_output\n\"\"\"",
    "enforcement": {
      "tool": "ruff D100-D107 rules",
      "ci_check": "CI fails on missing docstrings for public functions"
    }
  },
  "comment_philosophy": {
    "rule": "Comments explain WHY, never WHAT",
    "rationale": "AI can read code to understand WHAT; humans and AI need WHY for rationale",
    "examples": {
      "correct": [
        "# SHA-256 chosen for collision resistance and determinism per ADR-0004",
        "# Preserve artifacts on unlock to prevent data loss per ADR-0002",
        "# Windows requires spawn-safe concurrency; fork() unavailable"
      ],
      "incorrect": [
        "# Load the dataset",
        "# Iterate over items",
        "# Return the result"
      ]
    }
  },
  "directory_structure": {
    "rule": "Flat within modules, max 2 levels deep",
    "max_depth": 2,
    "example_correct": [
      "apps/data_aggregator/backend/src/dat/",
      "  stage_orchestrator.py",
      "  artifact_store.py",
      "  manifest_validator.py",
      "  adapters/",
      "    csv_adapter.py",
      "    parquet_adapter.py"
    ],
    "example_incorrect": [
      "apps/data_aggregator/backend/src/dat/",
      "  core/",
      "    orchestration/",
      "      stages/",
      "        implementations/",
      "          stage_orchestrator.py"
    ]
  },
  "import_organization": {
    "rule": "Absolute imports only, grouped by origin",
    "order": [
      "1. Standard library imports",
      "2. Third-party imports",
      "3. Local application imports"
    ],
    "separator": "Blank line between groups",
    "example": "from collections.abc import Mapping\nfrom pathlib import Path\n\nimport polars as pl\nfrom pydantic import BaseModel\n\nfrom shared.contracts.core.dataset import DataSetManifest\nfrom shared.storage.artifact_store import ArtifactStore",
    "enforcement": {
      "tool": "ruff I001/I002 rules (isort)",
      "ci_check": "CI fails on relative imports or wrong order"
    }
  },
  "class_naming": {
    "pattern": "PascalCase with descriptive suffix",
    "suffixes": ["Loader", "Orchestrator", "Store", "Validator", "Renderer", "Adapter", "Config", "Result"],
    "examples": ["DataSetLoader", "StageOrchestrator", "ArtifactStore", "ManifestValidator"]
  },
  "constant_naming": {
    "pattern": "SCREAMING_SNAKE_CASE",
    "location": "Module level",
    "examples": ["MAX_RETRIES", "DEFAULT_TIMEOUT", "SUPPORTED_FORMATS"]
  },
  "implementation_checklist": [
    "All Python files follow {domain}_{action}.py naming",
    "All functions follow {verb}_{noun} naming",
    "All public functions have Google-style docstrings",
    "Comments explain WHY, not WHAT",
    "Directory structure is max 2 levels deep within modules",
    "All imports are absolute, grouped correctly"
  ],
  "validation_commands": {
    "check_docstrings": "ruff check --select=D .",
    "check_imports": "ruff check --select=I .",
    "check_naming": "Custom script: tools/check_naming.py (to be created)"
  },
  "references": [
    "ADR-0033_AI-Assisted-Development-Patterns",
    "Google Python Style Guide: https://google.github.io/styleguide/pyguide.html",
    "PEP 257 - Docstring Conventions",
    "PEP 8 - Style Guide for Python Code"
  ],
  "tags": ["ai-assisted", "naming", "docstrings", "code-organization", "specification"]
}
